#!/usr/bin/env python3

# General outline and most comments generated by ChatGPT 3.5
def CreateMolecules(file):
    """
    This function returns a list of Molecules that have been read from a file
    """
    # Preliminary Data
    from Molecule import Molecule
    Mols = []

    # Create empty list that will be returned
    with open(file, 'r') as file:
        # Read each line in the file
        for line in file:
            # Remove leading/trailing whitespaces and newline characters
            files = line.strip()
            files = files.split()
            # Create an instance of the Molecule class with the file_name parameter
            Mols.append(Molecule(files[0],files[1]))

    # Return list of molecules
    return Mols

def GridPropRatios(mols):
    """
    This function loops through a list of molecules and creates a Matrix
    """
    import numpy as np
    import matplotlib.pyplot as plt
    from globaldata import GlobalData
    from BFOD import BFOD
    import mplcursors

    # Dictionary to store bond classes and their associated bond proportions
    bond_pairs = {}

    # Iterate through each bfod
    for bfod in GlobalData.mBFODs:
        # Create a unique key-value pair for each bonding type
        key = frozenset({bfod.mBold.mZ,bfod.mMeek.mZ})
        # Add key to dictionary if nonexistent.
        if key not in bond_pairs:
            bond_pairs[key] = []
        bond_pairs[key].append(bfod.mAssocFOD.mBoldPortion)

    # Initialize a dictionary to store the average bond proportions for each bond pair
    average_bond_proportions = {}

    # Calculate the average bond proportion for each bond pair
    for bond_pair, bond_proportions in bond_pairs.items():
        average_bond_proportions[bond_pair] = np.mean(bond_proportions)

    # Extract unique atomic numbers from bond pairs
    unique_atomic_numbers = set()
    for bond_pair in average_bond_proportions.keys():
        unique_atomic_numbers.update(bond_pair)

    # Create a sorted list of unique atomic numbers
    atomic_numbers_sorted = sorted(unique_atomic_numbers)

    # Create a matrix to store the average bond proportions
    matrix_size = len(atomic_numbers_sorted)
    bond_matrix = np.zeros((matrix_size, matrix_size))

    # Fill in the matrix with the average bond proportions
    for bond_pair, avg_bond_proportion in average_bond_proportions.items():
        atomic_numbers_list = sorted(list(bond_pair))
        if len(atomic_numbers_list) == 1:
            atomic_number = atomic_numbers_list[0]
            index = atomic_numbers_sorted.index(atomic_number)
            bond_matrix[index, index] = avg_bond_proportion
        else:
            atomic_number_1, atomic_number_2 = atomic_numbers_list
            index_1 = atomic_numbers_sorted.index(atomic_number_1)
            index_2 = atomic_numbers_sorted.index(atomic_number_2)
            bond_matrix[index_1, index_2] = avg_bond_proportion
            bond_matrix[index_2, index_1] = avg_bond_proportion
# Plot the heatmap with modified colormap and scaled data
    fig, ax = plt.subplots()
    heatmap = ax.imshow(bond_matrix, cmap='summer', interpolation='nearest', vmin=bond_matrix.min(), vmax=bond_matrix.max())
    plt.colorbar(heatmap, ax=ax, label='Average Bond Proportion')
    plt.xticks(np.arange(matrix_size), atomic_numbers_sorted)
    plt.yticks(np.arange(matrix_size), atomic_numbers_sorted)
    plt.xlabel('Atomic Number')
    plt.ylabel('Atomic Number')
    plt.title('Average Bond Proportion Matrix Heatmap')

    # Annotate the averages in the grid boxes
    for i in range(matrix_size):
        for j in range(matrix_size):
            ax.annotate(f'{bond_matrix[i, j]:.2f}', (j, i), color='black', ha='center', va='center')

    # Define a function to display data points associated with a specific cell
    def show_data_points(event):
        if event.xdata is not None and event.ydata is not None:
            i = int(round(event.ydata))
            j = int(round(event.xdata))
            bond_pair = frozenset({atomic_numbers_sorted[i], atomic_numbers_sorted[j]})
            data_points = bond_pairs.get(bond_pair, [])
            num_data_points = len(data_points)
            if num_data_points > 0:
                data_str = "\n".join([str(point) for point in data_points])
                ax_side.clear()
                ax_side.text(0, 0.5, f'Avg: {bond_matrix[i, j]:.2f}\nVar: {np.var(bond_matrix[i, j]):.2f}\nItems: {num_data_points}\nData Points:\n{data_str}', fontsize=10, verticalalignment='center')
                ax_side.set_xlim(0, 1)
                ax_side.set_ylim(0, 1)
                ax_side.axis('off')
                plt.draw()
            else:
                ax_side.clear()
                ax_side.set_xlim(0, 1)
                ax_side.set_ylim(0, 1)
                ax_side.axis('off')
                plt.draw()

    # Create a side subplot to display the data points
    ax_side = fig.add_axes([0.85, 0.1, 0.15, 0.8])
    ax_side.set_xlim(0, 1)
    ax_side.set_ylim(0, 1)
    ax_side.axis('off')

    # Connect the function to the figure for mouse click events
    fig.canvas.mpl_connect('button_press_event', show_data_points)

    # Save the image
    plt.show()